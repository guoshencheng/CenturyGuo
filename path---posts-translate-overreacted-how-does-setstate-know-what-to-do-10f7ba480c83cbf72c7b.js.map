{"version":3,"sources":["webpack:///path---posts-translate-overreacted-how-does-setstate-know-what-to-do-10f7ba480c83cbf72c7b.js","webpack:///./.cache/json/posts-translate-overreacted-how-does-setstate-know-what-to-do.json"],"names":["webpackJsonp","396","module","exports","data","markdownRemark","html","frontmatter","title","date","tag","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,w7sBAAylrBC,aAA2pDC,MAAA,sBAAAC,KAAA,oBAAAC,IAAA,2BAAyFC,aAAgBC,KAAA","file":"path---posts-translate-overreacted-how-does-setstate-know-what-to-do-10f7ba480c83cbf72c7b.js","sourcesContent":["webpackJsonp([226573307014922],{\n\n/***/ 396:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<blockquote>\\n<p>本文出自<a href=\\\"https://overreacted.io/\\\">overreacted</a>，这是<a href=\\\"https://mobile.twitter.com/dan_abramov\\\">Dan Abramov</a>写的博客，我觉得对很有用所以特意做了这个翻译<a href=\\\"/posts/overreacted\\\">系列</a>，原文链接请查看<a href=\\\"https://overreacted.io/how-does-setstate-know-what-to-do/\\\">这里</a></p>\\n</blockquote>\\n<p>当你在组件里调用<code class=\\\"language-text\\\">setState</code>的时候，你觉得发生了设么？</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"jsx\\\">\\n      <pre class=\\\"language-jsx\\\"><code class=\\\"language-jsx\\\"><span class=\\\"token keyword\\\">import</span> React <span class=\\\"token keyword\\\">from</span> <span class=\\\"token string\\\">'react'</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">import</span> ReactDOM <span class=\\\"token keyword\\\">from</span> <span class=\\\"token string\\\">'react-dom'</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Button</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">React<span class=\\\"token punctuation\\\">.</span>Component</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">super</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>state <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span> clicked<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">false</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>handleClick <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>handleClick<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">bind</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token function\\\">handleClick</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">setState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">{</span> clicked<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token function\\\">render</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>state<span class=\\\"token punctuation\\\">.</span>clicked<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">return</span> <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>h1</span><span class=\\\"token punctuation\\\">></span></span>Thanks<span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>h1</span><span class=\\\"token punctuation\\\">></span></span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token keyword\\\">return</span> <span class=\\\"token punctuation\\\">(</span>\\n      <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>button</span> <span class=\\\"token attr-name\\\">onClick</span><span class=\\\"token script language-javascript\\\"><span class=\\\"token script-punctuation punctuation\\\">=</span><span class=\\\"token punctuation\\\">{</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>handleClick<span class=\\\"token punctuation\\\">}</span></span><span class=\\\"token punctuation\\\">></span></span>\\n        Click me<span class=\\\"token operator\\\">!</span>\\n      <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>button</span><span class=\\\"token punctuation\\\">></span></span>\\n    <span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\nReactDOM<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">render</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>Button</span> <span class=\\\"token punctuation\\\">/></span></span><span class=\\\"token punctuation\\\">,</span> document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getElementById</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'container'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>或许和你想的一样，React 通过接下来的<code class=\\\"language-text\\\">{ clicked: true }</code>状态，重新执行了渲染的函数并且将让DOM更新成了<code class=\\\"language-text\\\">&lt;h1&gt;Thanks&lt;/h1&gt;</code>元素。</p>\\n<p>看起来非常简单。那么现在的问题是，究竟是<em>React</em>做了这些？还是<em>React DOM</em>?</p>\\n<p>更新DOM看起来应该是ReactDOM的职责。但当我们调用<code class=\\\"language-text\\\">this.setState()</code>，这却不应该是React DOM的任务。而<code class=\\\"language-text\\\">React.Component</code>这个基类的任务则是定义React元素内部的结构。</p>\\n<p>那么，我们是怎么能够在<code class=\\\"language-text\\\">React.Component</code>中调用<code class=\\\"language-text\\\">setState()</code>来更新DOM的呢？</p>\\n<p><strong>放弃的分割线：就想<a href=\\\"/trasnlate-overreacted-how-does-react-tell-a-class-from-a-function/\\\">大部分</a><a href=\\\"/trasnlate-overreacted-why-do-we-write-super-props/\\\">其他的在这个blog中的</a><a href=\\\"/trasnlate-overreacted-why-do-react-elements-have-typeof-property\\\">文章一样</a>。你在生产环境中使用React，你并不需要了解这么多。这篇文章是针对那些想要解开React工作内幕的。是否看下去，完全取决于读者的选择</strong></p>\\n<hr>\\n<p>你可能会猜测，是不是<code class=\\\"language-text\\\">React.Component</code>这个类包含了更新DOM的逻辑</p>\\n<p>但是如果是这么做的话，那为什么<code class=\\\"language-text\\\">this.setState()</code>能够在这么多的生态中都能使用？比如，React Native应用中的组件也是继承于<code class=\\\"language-text\\\">React.Component</code>。在React Native中像上面那样调用<code class=\\\"language-text\\\">this.setState()</code>，在Android或者iOS原生的页面上都能够非常正常的运行。</p>\\n<p>你可能对React对React Test Renderer 或者 Shallow Renderer比较熟悉。这些测试方案让你能够在运行这些测试的时候也能够渲染这些组件。而这些都没有涉及DOM。</p>\\n<p>如果你使用过其他的渲染器比如<a href=\\\"https://github.com/facebook/react/tree/master/packages/react-art\\\">React ART</a>，你就会知道，在同一个页面，我们还能同时使用很多渲染器。(比如说，在ReactDOM的DOM树中渲染ART组件)。这使得全局标志或变量无法维持。</p>\\n<p>因此 <strong><code class=\\\"language-text\\\">React.Component</code>将对于状态的改变的实现委托给了各个平台各自的代码</strong> 在我们能够理解这是怎么做到的之前，我们先研究一下为什么这些包会被分开以及是怎么分开的。</p>\\n<hr>\\n<p>这里有个普遍的误区就是大家会觉得React\\\"渲染引擎\\\"是在react的包内的。但这并不是对的。</p>\\n<p>事实上自从<a href=\\\"https://reactjs.org/blog/2015/07/03/react-v0.14-beta-1.html#two-packages\\\">React0.14的包分割</a>，<code class=\\\"language-text\\\">react</code>包只用于暴露一些定义组建的API接口。大部分的<em>实现</em>都被放到了\\\"renderer\\\"中</p>\\n<p><code class=\\\"language-text\\\">react-dom</code>, <code class=\\\"language-text\\\">react-dom/server</code>, <code class=\\\"language-text\\\">react-native</code>, <code class=\\\"language-text\\\">react-test-renderer</code>, <code class=\\\"language-text\\\">react-art</code>这些都是<code class=\\\"language-text\\\">renderer</code>(或者你也可以<a href=\\\"https://github.com/facebook/react/blob/master/packages/react-reconciler/README.md#practical-examples\\\">编写你自己的</a>)</p>\\n<p>这就是为什么<code class=\\\"language-text\\\">react</code>包不关注你所使用的平台是什么。他所输出的模块，比如<code class=\\\"language-text\\\">React.Component</code>，<code class=\\\"language-text\\\">React.createElement</code>，<code class=\\\"language-text\\\">React.Children</code>这些工具或者<a href=\\\"https://reactjs.org/docs/hooks-intro.html\\\">Hooks</a>，都是和目标平台无关的。无论你是使用React DOM或者React DOM Server或者React Native，你都可以把你的组件引入并使用。</p>\\n<p>相比之下，这些renderer包暴露了平台相关的API，比如 <code class=\\\"language-text\\\">ReactDOM.render()</code>让你能够将一个React树渲染到一个DOM节点上。每个renderer都提供了类似的API。通过这种方案，组件就不需要将关于renderer的东西引入了。这让他们更接口化。</p>\\n<p><strong>众所周知，React的渲染引擎在各个renderer中被实现</strong> 很多renderers在背部包含了一份react内部相同的代码 - 我们把这个叫做<a href=\\\"https://github.com/facebook/react/tree/master/packages/react-reconciler\\\">\\\"调节算法\\\"</a>。这些renderer将调节算法和renderer的代码整合成了一个高性能的渲染库。(复制核心的调节算法代码通常会影响最后包的大小，但是对于那些通常只是用一种renderer的开发者来说，还是可以接受的，比如<code class=\\\"language-text\\\">react-dom</code>)。</p>\\n<p><code class=\\\"language-text\\\">react</code>赋予你可以使用React的功能，但是不会让你知道他们是怎么实现的。这些renderer(<code class=\\\"language-text\\\">react-dom</code>, 'react-native' 等等)完成了React最后渲染和逻辑在各自平台上的实现。他们其中可能有的引用了内部的调节器，然后对于各自的平台，完成相应的实现。</p>\\n<hr>\\n<p>现在我们知道为什么<code class=\\\"language-text\\\">react</code>和<code class=\\\"language-text\\\">react-dom</code>包对于某一个功能都需要更新一个版本。比如，当React 16.3 添加了 Context API之后，React的包就暴露了<code class=\\\"language-text\\\">React.createContext()</code>的接口。</p>\\n<p>但是<code class=\\\"language-text\\\">React.createContext()</code>不是React自己实现了context这个功能。具体的实现在React DOM和React DOM Server中是不同的。所以<code class=\\\"language-text\\\">createContext()</code>只是返回若干个对象:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token comment\\\">// 做了一点简化</span>\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">createContext</span><span class=\\\"token punctuation\\\">(</span>defaultValue<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">let</span> context <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    _currentValue<span class=\\\"token punctuation\\\">:</span> defaultValue<span class=\\\"token punctuation\\\">,</span>\\n    Provider<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token keyword\\\">null</span><span class=\\\"token punctuation\\\">,</span>\\n    Consumer<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token keyword\\\">null</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  context<span class=\\\"token punctuation\\\">.</span>Provider <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    $$<span class=\\\"token keyword\\\">typeof</span><span class=\\\"token punctuation\\\">:</span> Symbol<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">for</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'react.provider'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span>\\n    _context<span class=\\\"token punctuation\\\">:</span> context\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  context<span class=\\\"token punctuation\\\">.</span>Consumer <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    $$<span class=\\\"token keyword\\\">typeof</span><span class=\\\"token punctuation\\\">:</span> Symbol<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">for</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'react.context'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span>\\n    _context<span class=\\\"token punctuation\\\">:</span> context<span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token keyword\\\">return</span> context<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>当你使用<code class=\\\"language-text\\\">&lt;MyContext.Provider&gt;</code> 或者 <code class=\\\"language-text\\\">&lt;MyContext.Consumer&gt;</code>的时候，其实是<em>renderer</em>来决定如何处理这些对象。React DOM和React DOM Server各自都会用不同的方式来处理context。</p>\\n<p><strong>所以当你更新到<code class=\\\"language-text\\\">react</code> 16.3+但是你没有跟新<code class=\\\"language-text\\\">react-dom</code>的话，你的renderer可能不能够准确的识别<code class=\\\"language-text\\\">Provider</code>和<code class=\\\"language-text\\\">Consumer</code>的结构</strong> 这也是为什么老版本的<code class=\\\"language-text\\\">react-dom</code>可能会<a href=\\\"https://stackoverflow.com/a/49677020/458193\\\">不能识别新的context的结构</a></p>\\n<p>同样的，React Native也有相同的问题。但是不像React DOM，React在更新之后不会立刻强制要求像React Native这样的包更新。这些包拥有自己的更新计划。renderer的更新是在React更新后的几周之内<a href=\\\"https://github.com/facebook/react-native/commits/master/Libraries/Renderer/oss\\\">同步更新</a>的。所以React Native和React DOM拥有不同的更新周期。</p>\\n<hr>\\n<p>所以我们现在知道<code class=\\\"language-text\\\">react</code>包没有什么update的实现，这些实现都被实现在了<code class=\\\"language-text\\\">react-dom</code>、<code class=\\\"language-text\\\">react-native</code>这些包里面，但这并没有解决我们的问题。<code class=\\\"language-text\\\">React.Component</code>的<code class=\\\"language-text\\\">setState()</code>是如何和这些renderer交互的。</p>\\n<p><strong>答案就是每个renderer都给React的实例添加了一个字段</strong> 这个字段被命名为<code class=\\\"language-text\\\">updater</code>。这个字段对于开发者来说是没有用的，也不需要去操作，这个字段应该由React DOM，React DOM Server或者React Native来设置，这些renderer会在创建一个React实例的时候创建这个字段:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token comment\\\">// React DOM 内部</span>\\n<span class=\\\"token keyword\\\">const</span> inst <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">YourComponent</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\ninst<span class=\\\"token punctuation\\\">.</span>props <span class=\\\"token operator\\\">=</span> props<span class=\\\"token punctuation\\\">;</span>\\ninst<span class=\\\"token punctuation\\\">.</span>updater <span class=\\\"token operator\\\">=</span> ReactDOMUpdater<span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token comment\\\">// React DOM Server 内部</span>\\n<span class=\\\"token keyword\\\">const</span> inst <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">YourComponent</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\ninst<span class=\\\"token punctuation\\\">.</span>props <span class=\\\"token operator\\\">=</span> props<span class=\\\"token punctuation\\\">;</span>\\ninst<span class=\\\"token punctuation\\\">.</span>updater <span class=\\\"token operator\\\">=</span> ReactDOMServerUpdater<span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token comment\\\">// React Native 内部</span>\\n<span class=\\\"token keyword\\\">const</span> inst <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">YourComponent</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\ninst<span class=\\\"token punctuation\\\">.</span>props <span class=\\\"token operator\\\">=</span> props<span class=\\\"token punctuation\\\">;</span>\\ninst<span class=\\\"token punctuation\\\">.</span>updater <span class=\\\"token operator\\\">=</span> ReactNativeUpdater<span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>查看一下<a href=\\\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react/src/ReactBaseClasses.js#L58-L67\\\"><code class=\\\"language-text\\\">setState</code>在<code class=\\\"language-text\\\">React.Component</code>中的实现</a>，<code class=\\\"language-text\\\">setState</code>做的只是将所有的处理交给创建React实例时候的renderer:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token comment\\\">// 简化一下</span>\\n<span class=\\\"token function\\\">setState</span><span class=\\\"token punctuation\\\">(</span>partialState<span class=\\\"token punctuation\\\">,</span> callback<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token comment\\\">// 使用`updater`来调用renderer的逻辑!</span>\\n  <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>updater<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">enqueueSetState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">,</span> partialState<span class=\\\"token punctuation\\\">,</span> callback<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>React DOM Server <a href=\\\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-dom/src/server/ReactPartialRenderer.js#L442-L448\\\">可能会</a>忽略state的更新并抛出一个警告，而React DOM 和React Native会让他们的调节器来<a href=\\\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-reconciler/src/ReactFiberClassComponent.js#L190-L207\\\">处理</a>state的更新 </p>\\n<p>这就是为什么<code class=\\\"language-text\\\">this.setState()</code>可以更新DOM，即使在React的包中并没有定义如何更新DOM。这个函数会地调用React DOM 添加的<code class=\\\"language-text\\\">this.updater</code>的处理方法，并且让React DOM来主持这次更新。</p>\\n<hr>\\n<p>我们现在明白了React.Component的类是如何工作的了，那么Hooks又是如何工作的呢？</p>\\n<p>当开发者看到<a href=\\\"https://reactjs.org/docs/hooks-intro.html\\\">Hook 提案 API</a>了之后，可能会疑惑：<code class=\\\"language-text\\\">useState</code>又是怎么知道具体应该怎么更新的呢？他们可能会猜想这实现的方式可能会比<code class=\\\"language-text\\\">React.Component</code>的<code class=\\\"language-text\\\">this.setState()</code>更加\\\"神奇\\\"。</p>\\n<p>但是从我们现在来看，其实React.Component的<code class=\\\"language-text\\\">setState()</code>的实现只是一个空壳。他只是将任务交给了renderer。而其实<code class=\\\"language-text\\\">useState</code>Hook<a href=\\\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react/src/ReactHooks.js#L55-L56\\\">做了相同的事情</a></p>\\n<p><strong>相比于添加了一个<code class=\\\"language-text\\\">updater</code>的字段，Hooks添加了一个\\\"dispatcher\\\"的字段</strong> 当你在调用<code class=\\\"language-text\\\">React.useState()</code>或者<code class=\\\"language-text\\\">React.useEffect()</code>之类的Hook的时候，其实最后会被交给当前的disaptcher来处理。</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token comment\\\">// 在 React 中(简化了一下) </span>\\n<span class=\\\"token keyword\\\">const</span> React <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token comment\\\">// 真实的属性被藏在更深处，你可以尝试自己找一下</span>\\n  __currentDispatcher<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token keyword\\\">null</span><span class=\\\"token punctuation\\\">,</span>\\n\\n  <span class=\\\"token function\\\">useState</span><span class=\\\"token punctuation\\\">(</span>initialState<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> React<span class=\\\"token punctuation\\\">.</span>__currentDispatcher<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">useState</span><span class=\\\"token punctuation\\\">(</span>initialState<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n\\n  <span class=\\\"token function\\\">useEffect</span><span class=\\\"token punctuation\\\">(</span>initialState<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> React<span class=\\\"token punctuation\\\">.</span>__currentDispatcher<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">useEffect</span><span class=\\\"token punctuation\\\">(</span>initialState<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token comment\\\">// ...</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>每个renderer会在渲染一个组件之前先设置dispatcher:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token comment\\\">// 在 React DOM中</span>\\n<span class=\\\"token keyword\\\">const</span> prevDispatcher <span class=\\\"token operator\\\">=</span> React<span class=\\\"token punctuation\\\">.</span>__currentDispatcher<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"gatsby-highlight-code-line\\\">React<span class=\\\"token punctuation\\\">.</span>__currentDispatcher <span class=\\\"token operator\\\">=</span> ReactDOMDispatcher<span class=\\\"token punctuation\\\">;</span>\\n</span><span class=\\\"token keyword\\\">let</span> result<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n  result <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">YourComponent</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">finally</span> <span class=\\\"token punctuation\\\">{</span>\\n<span class=\\\"gatsby-highlight-code-line\\\">  <span class=\\\"token comment\\\">// Restore it back</span>\\n</span><span class=\\\"gatsby-highlight-code-line\\\">  React<span class=\\\"token punctuation\\\">.</span>__currentDispatcher <span class=\\\"token operator\\\">=</span> prevDispatcher<span class=\\\"token punctuation\\\">;</span>\\n</span><span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>比如React DOM Server的实现是<a href=\\\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-dom/src/server/ReactPartialRendererHooks.js#L340-L354\\\">这样的</a>，而React DOM 和React Native中的调解器实现是<a href=\\\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-reconciler/src/ReactFiberHooks.js\\\">这样的</a>。</p>\\n<p>这也是为什么一些像<code class=\\\"language-text\\\">react-dom</code>这样的renderer在使用Hooks的时候需要相同版本的<code class=\\\"language-text\\\">react</code>包，否则，你的组件可能不能找到dispatcher!当你使用<a href=\\\"https://github.com/facebook/react/issues/13991\\\">不同版本的React</a>的时候，Hook就会不起作用。像这种情况总是会产生一些无法归宿问题的bug，所以Hooks会在这些bug出现之前，强制让你使用相同的React包。</p>\\n<p>虽然我们不推荐这么做，但是在特定的调试情况下，你也可以自己重写dispatcher。(我之前说的<code class=\\\"language-text\\\">__currentDispatcher</code>这个字段不是真实的，你可以通过React仓库自行找出真实的字段)比如 React DevTools就会使用一个特殊的<a href=\\\"ttps://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-debug-tools/src/ReactDebugHooks.js#L203-L214\\\">dispatcher</a> 来通过追踪Javascript的调用栈来审查Hooks树。<em>Don’t repeat this at home.</em>(小朋友别乱玩)</p>\\n<p>这也意味着Hooks并不是强关联React。如果之后会有更多的库来使用这些基本的Hooks，理论上disaptcher会被分到其他的包里面并暴露一个更加友善的API。</p>\\n<p><code class=\\\"language-text\\\">updater</code>和<code class=\\\"language-text\\\">__currentDispatcher</code>这两个字段遵循了一个<em>依赖注入</em>的通用编程理念。这两种实现中，renderer将<code class=\\\"language-text\\\">setState</code>的实现注入到React的包中，让你的组件可以被方便的定义。</p>\\n<p>你在使用React的时候并不需要去思考这些。我们希望React的开发者能够花更多的事件在他们的应用代码上，而不是这些抽象的概念，比如 依赖注入。但是如果你曾对<code class=\\\"language-text\\\">this.setStete()</code>护着<code class=\\\"language-text\\\">useState()</code>是如何工作的非常好奇，这篇文章会帮助到你。</p>\\n<hr>\",\"frontmatter\":{\"title\":\"翻译：setState是如何处理更新的\",\"date\":\"09 December, 2018\",\"tag\":\"translate,overreacted\"}}},\"pathContext\":{\"slug\":\"translate-overreacted-how-does-setstate-know-what-to-do\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---posts-translate-overreacted-how-does-setstate-know-what-to-do-10f7ba480c83cbf72c7b.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<blockquote>\\n<p>本文出自<a href=\\\"https://overreacted.io/\\\">overreacted</a>，这是<a href=\\\"https://mobile.twitter.com/dan_abramov\\\">Dan Abramov</a>写的博客，我觉得对很有用所以特意做了这个翻译<a href=\\\"/posts/overreacted\\\">系列</a>，原文链接请查看<a href=\\\"https://overreacted.io/how-does-setstate-know-what-to-do/\\\">这里</a></p>\\n</blockquote>\\n<p>当你在组件里调用<code class=\\\"language-text\\\">setState</code>的时候，你觉得发生了设么？</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"jsx\\\">\\n      <pre class=\\\"language-jsx\\\"><code class=\\\"language-jsx\\\"><span class=\\\"token keyword\\\">import</span> React <span class=\\\"token keyword\\\">from</span> <span class=\\\"token string\\\">'react'</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">import</span> ReactDOM <span class=\\\"token keyword\\\">from</span> <span class=\\\"token string\\\">'react-dom'</span><span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Button</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">React<span class=\\\"token punctuation\\\">.</span>Component</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">super</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>state <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span> clicked<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">false</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>handleClick <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>handleClick<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">bind</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token function\\\">handleClick</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">setState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">{</span> clicked<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token function\\\">render</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>state<span class=\\\"token punctuation\\\">.</span>clicked<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">return</span> <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>h1</span><span class=\\\"token punctuation\\\">></span></span>Thanks<span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>h1</span><span class=\\\"token punctuation\\\">></span></span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token keyword\\\">return</span> <span class=\\\"token punctuation\\\">(</span>\\n      <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>button</span> <span class=\\\"token attr-name\\\">onClick</span><span class=\\\"token script language-javascript\\\"><span class=\\\"token script-punctuation punctuation\\\">=</span><span class=\\\"token punctuation\\\">{</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>handleClick<span class=\\\"token punctuation\\\">}</span></span><span class=\\\"token punctuation\\\">></span></span>\\n        Click me<span class=\\\"token operator\\\">!</span>\\n      <span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;/</span>button</span><span class=\\\"token punctuation\\\">></span></span>\\n    <span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\nReactDOM<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">render</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token tag\\\"><span class=\\\"token tag\\\"><span class=\\\"token punctuation\\\">&lt;</span>Button</span> <span class=\\\"token punctuation\\\">/></span></span><span class=\\\"token punctuation\\\">,</span> document<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getElementById</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'container'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>或许和你想的一样，React 通过接下来的<code class=\\\"language-text\\\">{ clicked: true }</code>状态，重新执行了渲染的函数并且将让DOM更新成了<code class=\\\"language-text\\\">&lt;h1&gt;Thanks&lt;/h1&gt;</code>元素。</p>\\n<p>看起来非常简单。那么现在的问题是，究竟是<em>React</em>做了这些？还是<em>React DOM</em>?</p>\\n<p>更新DOM看起来应该是ReactDOM的职责。但当我们调用<code class=\\\"language-text\\\">this.setState()</code>，这却不应该是React DOM的任务。而<code class=\\\"language-text\\\">React.Component</code>这个基类的任务则是定义React元素内部的结构。</p>\\n<p>那么，我们是怎么能够在<code class=\\\"language-text\\\">React.Component</code>中调用<code class=\\\"language-text\\\">setState()</code>来更新DOM的呢？</p>\\n<p><strong>放弃的分割线：就想<a href=\\\"/trasnlate-overreacted-how-does-react-tell-a-class-from-a-function/\\\">大部分</a><a href=\\\"/trasnlate-overreacted-why-do-we-write-super-props/\\\">其他的在这个blog中的</a><a href=\\\"/trasnlate-overreacted-why-do-react-elements-have-typeof-property\\\">文章一样</a>。你在生产环境中使用React，你并不需要了解这么多。这篇文章是针对那些想要解开React工作内幕的。是否看下去，完全取决于读者的选择</strong></p>\\n<hr>\\n<p>你可能会猜测，是不是<code class=\\\"language-text\\\">React.Component</code>这个类包含了更新DOM的逻辑</p>\\n<p>但是如果是这么做的话，那为什么<code class=\\\"language-text\\\">this.setState()</code>能够在这么多的生态中都能使用？比如，React Native应用中的组件也是继承于<code class=\\\"language-text\\\">React.Component</code>。在React Native中像上面那样调用<code class=\\\"language-text\\\">this.setState()</code>，在Android或者iOS原生的页面上都能够非常正常的运行。</p>\\n<p>你可能对React对React Test Renderer 或者 Shallow Renderer比较熟悉。这些测试方案让你能够在运行这些测试的时候也能够渲染这些组件。而这些都没有涉及DOM。</p>\\n<p>如果你使用过其他的渲染器比如<a href=\\\"https://github.com/facebook/react/tree/master/packages/react-art\\\">React ART</a>，你就会知道，在同一个页面，我们还能同时使用很多渲染器。(比如说，在ReactDOM的DOM树中渲染ART组件)。这使得全局标志或变量无法维持。</p>\\n<p>因此 <strong><code class=\\\"language-text\\\">React.Component</code>将对于状态的改变的实现委托给了各个平台各自的代码</strong> 在我们能够理解这是怎么做到的之前，我们先研究一下为什么这些包会被分开以及是怎么分开的。</p>\\n<hr>\\n<p>这里有个普遍的误区就是大家会觉得React\\\"渲染引擎\\\"是在react的包内的。但这并不是对的。</p>\\n<p>事实上自从<a href=\\\"https://reactjs.org/blog/2015/07/03/react-v0.14-beta-1.html#two-packages\\\">React0.14的包分割</a>，<code class=\\\"language-text\\\">react</code>包只用于暴露一些定义组建的API接口。大部分的<em>实现</em>都被放到了\\\"renderer\\\"中</p>\\n<p><code class=\\\"language-text\\\">react-dom</code>, <code class=\\\"language-text\\\">react-dom/server</code>, <code class=\\\"language-text\\\">react-native</code>, <code class=\\\"language-text\\\">react-test-renderer</code>, <code class=\\\"language-text\\\">react-art</code>这些都是<code class=\\\"language-text\\\">renderer</code>(或者你也可以<a href=\\\"https://github.com/facebook/react/blob/master/packages/react-reconciler/README.md#practical-examples\\\">编写你自己的</a>)</p>\\n<p>这就是为什么<code class=\\\"language-text\\\">react</code>包不关注你所使用的平台是什么。他所输出的模块，比如<code class=\\\"language-text\\\">React.Component</code>，<code class=\\\"language-text\\\">React.createElement</code>，<code class=\\\"language-text\\\">React.Children</code>这些工具或者<a href=\\\"https://reactjs.org/docs/hooks-intro.html\\\">Hooks</a>，都是和目标平台无关的。无论你是使用React DOM或者React DOM Server或者React Native，你都可以把你的组件引入并使用。</p>\\n<p>相比之下，这些renderer包暴露了平台相关的API，比如 <code class=\\\"language-text\\\">ReactDOM.render()</code>让你能够将一个React树渲染到一个DOM节点上。每个renderer都提供了类似的API。通过这种方案，组件就不需要将关于renderer的东西引入了。这让他们更接口化。</p>\\n<p><strong>众所周知，React的渲染引擎在各个renderer中被实现</strong> 很多renderers在背部包含了一份react内部相同的代码 - 我们把这个叫做<a href=\\\"https://github.com/facebook/react/tree/master/packages/react-reconciler\\\">\\\"调节算法\\\"</a>。这些renderer将调节算法和renderer的代码整合成了一个高性能的渲染库。(复制核心的调节算法代码通常会影响最后包的大小，但是对于那些通常只是用一种renderer的开发者来说，还是可以接受的，比如<code class=\\\"language-text\\\">react-dom</code>)。</p>\\n<p><code class=\\\"language-text\\\">react</code>赋予你可以使用React的功能，但是不会让你知道他们是怎么实现的。这些renderer(<code class=\\\"language-text\\\">react-dom</code>, 'react-native' 等等)完成了React最后渲染和逻辑在各自平台上的实现。他们其中可能有的引用了内部的调节器，然后对于各自的平台，完成相应的实现。</p>\\n<hr>\\n<p>现在我们知道为什么<code class=\\\"language-text\\\">react</code>和<code class=\\\"language-text\\\">react-dom</code>包对于某一个功能都需要更新一个版本。比如，当React 16.3 添加了 Context API之后，React的包就暴露了<code class=\\\"language-text\\\">React.createContext()</code>的接口。</p>\\n<p>但是<code class=\\\"language-text\\\">React.createContext()</code>不是React自己实现了context这个功能。具体的实现在React DOM和React DOM Server中是不同的。所以<code class=\\\"language-text\\\">createContext()</code>只是返回若干个对象:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token comment\\\">// 做了一点简化</span>\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">createContext</span><span class=\\\"token punctuation\\\">(</span>defaultValue<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">let</span> context <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    _currentValue<span class=\\\"token punctuation\\\">:</span> defaultValue<span class=\\\"token punctuation\\\">,</span>\\n    Provider<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token keyword\\\">null</span><span class=\\\"token punctuation\\\">,</span>\\n    Consumer<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token keyword\\\">null</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  context<span class=\\\"token punctuation\\\">.</span>Provider <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    $$<span class=\\\"token keyword\\\">typeof</span><span class=\\\"token punctuation\\\">:</span> Symbol<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">for</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'react.provider'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span>\\n    _context<span class=\\\"token punctuation\\\">:</span> context\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  context<span class=\\\"token punctuation\\\">.</span>Consumer <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n    $$<span class=\\\"token keyword\\\">typeof</span><span class=\\\"token punctuation\\\">:</span> Symbol<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">for</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'react.context'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span>\\n    _context<span class=\\\"token punctuation\\\">:</span> context<span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token keyword\\\">return</span> context<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>当你使用<code class=\\\"language-text\\\">&lt;MyContext.Provider&gt;</code> 或者 <code class=\\\"language-text\\\">&lt;MyContext.Consumer&gt;</code>的时候，其实是<em>renderer</em>来决定如何处理这些对象。React DOM和React DOM Server各自都会用不同的方式来处理context。</p>\\n<p><strong>所以当你更新到<code class=\\\"language-text\\\">react</code> 16.3+但是你没有跟新<code class=\\\"language-text\\\">react-dom</code>的话，你的renderer可能不能够准确的识别<code class=\\\"language-text\\\">Provider</code>和<code class=\\\"language-text\\\">Consumer</code>的结构</strong> 这也是为什么老版本的<code class=\\\"language-text\\\">react-dom</code>可能会<a href=\\\"https://stackoverflow.com/a/49677020/458193\\\">不能识别新的context的结构</a></p>\\n<p>同样的，React Native也有相同的问题。但是不像React DOM，React在更新之后不会立刻强制要求像React Native这样的包更新。这些包拥有自己的更新计划。renderer的更新是在React更新后的几周之内<a href=\\\"https://github.com/facebook/react-native/commits/master/Libraries/Renderer/oss\\\">同步更新</a>的。所以React Native和React DOM拥有不同的更新周期。</p>\\n<hr>\\n<p>所以我们现在知道<code class=\\\"language-text\\\">react</code>包没有什么update的实现，这些实现都被实现在了<code class=\\\"language-text\\\">react-dom</code>、<code class=\\\"language-text\\\">react-native</code>这些包里面，但这并没有解决我们的问题。<code class=\\\"language-text\\\">React.Component</code>的<code class=\\\"language-text\\\">setState()</code>是如何和这些renderer交互的。</p>\\n<p><strong>答案就是每个renderer都给React的实例添加了一个字段</strong> 这个字段被命名为<code class=\\\"language-text\\\">updater</code>。这个字段对于开发者来说是没有用的，也不需要去操作，这个字段应该由React DOM，React DOM Server或者React Native来设置，这些renderer会在创建一个React实例的时候创建这个字段:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token comment\\\">// React DOM 内部</span>\\n<span class=\\\"token keyword\\\">const</span> inst <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">YourComponent</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\ninst<span class=\\\"token punctuation\\\">.</span>props <span class=\\\"token operator\\\">=</span> props<span class=\\\"token punctuation\\\">;</span>\\ninst<span class=\\\"token punctuation\\\">.</span>updater <span class=\\\"token operator\\\">=</span> ReactDOMUpdater<span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token comment\\\">// React DOM Server 内部</span>\\n<span class=\\\"token keyword\\\">const</span> inst <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">YourComponent</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\ninst<span class=\\\"token punctuation\\\">.</span>props <span class=\\\"token operator\\\">=</span> props<span class=\\\"token punctuation\\\">;</span>\\ninst<span class=\\\"token punctuation\\\">.</span>updater <span class=\\\"token operator\\\">=</span> ReactDOMServerUpdater<span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token comment\\\">// React Native 内部</span>\\n<span class=\\\"token keyword\\\">const</span> inst <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">YourComponent</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\ninst<span class=\\\"token punctuation\\\">.</span>props <span class=\\\"token operator\\\">=</span> props<span class=\\\"token punctuation\\\">;</span>\\ninst<span class=\\\"token punctuation\\\">.</span>updater <span class=\\\"token operator\\\">=</span> ReactNativeUpdater<span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>查看一下<a href=\\\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react/src/ReactBaseClasses.js#L58-L67\\\"><code class=\\\"language-text\\\">setState</code>在<code class=\\\"language-text\\\">React.Component</code>中的实现</a>，<code class=\\\"language-text\\\">setState</code>做的只是将所有的处理交给创建React实例时候的renderer:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token comment\\\">// 简化一下</span>\\n<span class=\\\"token function\\\">setState</span><span class=\\\"token punctuation\\\">(</span>partialState<span class=\\\"token punctuation\\\">,</span> callback<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token comment\\\">// 使用`updater`来调用renderer的逻辑!</span>\\n  <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>updater<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">enqueueSetState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">,</span> partialState<span class=\\\"token punctuation\\\">,</span> callback<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>React DOM Server <a href=\\\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-dom/src/server/ReactPartialRenderer.js#L442-L448\\\">可能会</a>忽略state的更新并抛出一个警告，而React DOM 和React Native会让他们的调节器来<a href=\\\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-reconciler/src/ReactFiberClassComponent.js#L190-L207\\\">处理</a>state的更新 </p>\\n<p>这就是为什么<code class=\\\"language-text\\\">this.setState()</code>可以更新DOM，即使在React的包中并没有定义如何更新DOM。这个函数会地调用React DOM 添加的<code class=\\\"language-text\\\">this.updater</code>的处理方法，并且让React DOM来主持这次更新。</p>\\n<hr>\\n<p>我们现在明白了React.Component的类是如何工作的了，那么Hooks又是如何工作的呢？</p>\\n<p>当开发者看到<a href=\\\"https://reactjs.org/docs/hooks-intro.html\\\">Hook 提案 API</a>了之后，可能会疑惑：<code class=\\\"language-text\\\">useState</code>又是怎么知道具体应该怎么更新的呢？他们可能会猜想这实现的方式可能会比<code class=\\\"language-text\\\">React.Component</code>的<code class=\\\"language-text\\\">this.setState()</code>更加\\\"神奇\\\"。</p>\\n<p>但是从我们现在来看，其实React.Component的<code class=\\\"language-text\\\">setState()</code>的实现只是一个空壳。他只是将任务交给了renderer。而其实<code class=\\\"language-text\\\">useState</code>Hook<a href=\\\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react/src/ReactHooks.js#L55-L56\\\">做了相同的事情</a></p>\\n<p><strong>相比于添加了一个<code class=\\\"language-text\\\">updater</code>的字段，Hooks添加了一个\\\"dispatcher\\\"的字段</strong> 当你在调用<code class=\\\"language-text\\\">React.useState()</code>或者<code class=\\\"language-text\\\">React.useEffect()</code>之类的Hook的时候，其实最后会被交给当前的disaptcher来处理。</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token comment\\\">// 在 React 中(简化了一下) </span>\\n<span class=\\\"token keyword\\\">const</span> React <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token comment\\\">// 真实的属性被藏在更深处，你可以尝试自己找一下</span>\\n  __currentDispatcher<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token keyword\\\">null</span><span class=\\\"token punctuation\\\">,</span>\\n\\n  <span class=\\\"token function\\\">useState</span><span class=\\\"token punctuation\\\">(</span>initialState<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> React<span class=\\\"token punctuation\\\">.</span>__currentDispatcher<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">useState</span><span class=\\\"token punctuation\\\">(</span>initialState<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n\\n  <span class=\\\"token function\\\">useEffect</span><span class=\\\"token punctuation\\\">(</span>initialState<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> React<span class=\\\"token punctuation\\\">.</span>__currentDispatcher<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">useEffect</span><span class=\\\"token punctuation\\\">(</span>initialState<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token comment\\\">// ...</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>每个renderer会在渲染一个组件之前先设置dispatcher:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token comment\\\">// 在 React DOM中</span>\\n<span class=\\\"token keyword\\\">const</span> prevDispatcher <span class=\\\"token operator\\\">=</span> React<span class=\\\"token punctuation\\\">.</span>__currentDispatcher<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"gatsby-highlight-code-line\\\">React<span class=\\\"token punctuation\\\">.</span>__currentDispatcher <span class=\\\"token operator\\\">=</span> ReactDOMDispatcher<span class=\\\"token punctuation\\\">;</span>\\n</span><span class=\\\"token keyword\\\">let</span> result<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n  result <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">YourComponent</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">finally</span> <span class=\\\"token punctuation\\\">{</span>\\n<span class=\\\"gatsby-highlight-code-line\\\">  <span class=\\\"token comment\\\">// Restore it back</span>\\n</span><span class=\\\"gatsby-highlight-code-line\\\">  React<span class=\\\"token punctuation\\\">.</span>__currentDispatcher <span class=\\\"token operator\\\">=</span> prevDispatcher<span class=\\\"token punctuation\\\">;</span>\\n</span><span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>比如React DOM Server的实现是<a href=\\\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-dom/src/server/ReactPartialRendererHooks.js#L340-L354\\\">这样的</a>，而React DOM 和React Native中的调解器实现是<a href=\\\"https://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-reconciler/src/ReactFiberHooks.js\\\">这样的</a>。</p>\\n<p>这也是为什么一些像<code class=\\\"language-text\\\">react-dom</code>这样的renderer在使用Hooks的时候需要相同版本的<code class=\\\"language-text\\\">react</code>包，否则，你的组件可能不能找到dispatcher!当你使用<a href=\\\"https://github.com/facebook/react/issues/13991\\\">不同版本的React</a>的时候，Hook就会不起作用。像这种情况总是会产生一些无法归宿问题的bug，所以Hooks会在这些bug出现之前，强制让你使用相同的React包。</p>\\n<p>虽然我们不推荐这么做，但是在特定的调试情况下，你也可以自己重写dispatcher。(我之前说的<code class=\\\"language-text\\\">__currentDispatcher</code>这个字段不是真实的，你可以通过React仓库自行找出真实的字段)比如 React DevTools就会使用一个特殊的<a href=\\\"ttps://github.com/facebook/react/blob/ce43a8cd07c355647922480977b46713bd51883e/packages/react-debug-tools/src/ReactDebugHooks.js#L203-L214\\\">dispatcher</a> 来通过追踪Javascript的调用栈来审查Hooks树。<em>Don’t repeat this at home.</em>(小朋友别乱玩)</p>\\n<p>这也意味着Hooks并不是强关联React。如果之后会有更多的库来使用这些基本的Hooks，理论上disaptcher会被分到其他的包里面并暴露一个更加友善的API。</p>\\n<p><code class=\\\"language-text\\\">updater</code>和<code class=\\\"language-text\\\">__currentDispatcher</code>这两个字段遵循了一个<em>依赖注入</em>的通用编程理念。这两种实现中，renderer将<code class=\\\"language-text\\\">setState</code>的实现注入到React的包中，让你的组件可以被方便的定义。</p>\\n<p>你在使用React的时候并不需要去思考这些。我们希望React的开发者能够花更多的事件在他们的应用代码上，而不是这些抽象的概念，比如 依赖注入。但是如果你曾对<code class=\\\"language-text\\\">this.setStete()</code>护着<code class=\\\"language-text\\\">useState()</code>是如何工作的非常好奇，这篇文章会帮助到你。</p>\\n<hr>\",\"frontmatter\":{\"title\":\"翻译：setState是如何处理更新的\",\"date\":\"09 December, 2018\",\"tag\":\"translate,overreacted\"}}},\"pathContext\":{\"slug\":\"translate-overreacted-how-does-setstate-know-what-to-do\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/posts-translate-overreacted-how-does-setstate-know-what-to-do.json\n// module id = 396\n// module chunks = 226573307014922"],"sourceRoot":""}