{"version":3,"sources":["webpack:///path---posts-node-cluster-in-egg-20fc589c4c6c0d898f06.js","webpack:///./.cache/json/posts-node-cluster-in-egg.json"],"names":["webpackJsonp","384","module","exports","data","markdownRemark","html","frontmatter","title","date","tag","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,++vBAAi6wBC,aAA0eC,MAAA,WAAAC,KAAA,oBAAAC,IAAA,cAAiEC,aAAgBC,KAAA","file":"path---posts-node-cluster-in-egg-20fc589c4c6c0d898f06.js","sourcesContent":["webpackJsonp([236081119161127],{\n\n/***/ 384:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<blockquote>\\n<p>在之前的文章<a href=\\\"/posts/pre-deep-into-egg-core\\\">深入egg-core前篇</a>中已经讲述了一个道理，node之所以没有成为一个比较流行的服务器语言，是因为node需要一个企业级的框架。而egg或许是一个不错的选择，针对egg-core的内部实现，将会在这篇文章中作出探索。</p>\\n</blockquote>\\n<p>初学node来编写server一般都是简单的启动一个挂起的的node进程:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token comment\\\">// server.js</span>\\n<span class=\\\"token keyword\\\">const</span> server <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'http'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">createServer</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span><span class=\\\"token punctuation\\\">(</span>req<span class=\\\"token punctuation\\\">,</span> res<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  res<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">write</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'ok'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  res<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">end</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nserver<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">listen</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">3000</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>启动这个server.js后，会启动一个挂起的node的进程，然后我们访问<a href=\\\"http://localhost:3000\\\">页面</a>的时候就会收到返回值了。</p>\\n<p>这是比较基本的启动一个node服务的方式，但是这种方式太基础，没有考虑到生产环境的需求。一个服务被部署到生产环境会衍生出一些额外的需求：</p>\\n<ul>\\n<li>\\n<p><strong>可扩展性</strong> 生产环境中，用户的访问量不是像我们启动一个服务器来测试这样小的规模，有的时候会有较大的并发量，我们通常会采用集群的方式来解决这个问题，即发布启动若干个服务，然后让请求负载到这些服务上，就可以将较大的访问量拆解到比较合适的访问量，所以服务的可扩展性是很重要的。node是单进程处理请求的，所以有的时候我们可能会让一个端口的监听事件发布到若干个node进程中，也会起到负载均衡的作用。</p>\\n</li>\\n<li>\\n<p><strong>健壮性</strong> 在egg的<a href=\\\"https://eggjs.org/zh-cn/core/cluster-and-ipc.html#%E8%BF%9B%E7%A8%8B%E5%AE%88%E6%8A%A4\\\">文档</a>中也是有提到的，node在遇到未捕获异常的时候会退出，如果没有一个兜底的处理的话，最后应用会挂掉，这在生产环境中是不可容忍的，针对这点Node提供了<code class=\\\"language-text\\\">process.on(&#39;uncaughtException&#39;, handler)</code>来处理这个异常。</p>\\n</li>\\n</ul>\\n<p>egg在这方面有相关的处理，这些处理大部分都被放在<a href=\\\"https://github.com/eggjs/egg-cluster\\\">egg-cluster</a>中，在官方文档中，有明确的图阐述了内部的egg-cluster的处理逻辑:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">                +--------+          +-------+\\n                | Master |&lt;--------&gt;| Agent |\\n                +--------+          +-------+\\n                ^   ^    ^\\n               /    |     \\\\\\n             /      |       \\\\\\n           /        |         \\\\\\n         v          v          v\\n+----------+   +----------+   +----------+\\n| Worker 1 |   | Worker 2 |   | Worker 3 |\\n+----------+   +----------+   +----------+</code></pre>\\n      </div>\\n<p>假如我们启动了一个生产环境的egg服务，我们通常会执行:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"bash\\\">\\n      <pre class=\\\"language-bash\\\"><code class=\\\"language-bash\\\">egg-scripts start --daemon --title<span class=\\\"token operator\\\">=</span>xxxxx</code></pre>\\n      </div>\\n<p>这里的egg-scripts的命令行工具，我们可以一窥</p>\\n<p>在其项目中的<code class=\\\"language-text\\\">start.js</code>的脚本中，组装了一些命令行参数，最后会执行<code class=\\\"language-text\\\">start-cluster</code>这个node脚本:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token keyword\\\">const</span> options <span class=\\\"token operator\\\">=</span> <span class=\\\"token constant\\\">JSON</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">parse</span><span class=\\\"token punctuation\\\">(</span>process<span class=\\\"token punctuation\\\">.</span>argv<span class=\\\"token punctuation\\\">[</span><span class=\\\"token number\\\">2</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span>options<span class=\\\"token punctuation\\\">.</span>framework<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">startCluster</span><span class=\\\"token punctuation\\\">(</span>options<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>这里的framework是什么，默认是egg提供的framework，你也可以像<a href=\\\"https://eggjs.org/zh-cn/advanced/framework.html\\\">文档</a>中说的一样，自己定义一个framework，在配置文件中指明使用自己的framework，在framework中，需要被导出一个<code class=\\\"language-text\\\">startCluster</code>的函数，这个函数就是这里被调用的函数。在官方默认的egg的framework中，只是直接引用了<code class=\\\"language-text\\\">egg-cluster</code>的输出:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\">exports<span class=\\\"token punctuation\\\">.</span>startCluster <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'egg-cluster'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>startCluster<span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>关注一下<code class=\\\"language-text\\\">egg-cluster</code>中的实现，可以发现，startCluster的第一步，就是创建一个Master:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\">exports<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function-variable function\\\">startCluster</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span><span class=\\\"token punctuation\\\">(</span>options<span class=\\\"token punctuation\\\">,</span> callback<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Master</span><span class=\\\"token punctuation\\\">(</span>options<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">ready</span><span class=\\\"token punctuation\\\">(</span>callback<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>在官方文档中有这样的描述:</p>\\n<ul>\\n<li><strong>startCluster 启动传入 baseDir 和 framework，Master 进程启动</strong></li>\\n<li>\\n<p><strong>Master 先 fork Agent Worker</strong></p>\\n<ul>\\n<li>根据 framework 找到框架目录，实例化该框架的 Agent 类</li>\\n<li>Agent 找到定义的 AgentWorkerLoader，开始进行加载</li>\\n<li>AgentWorkerLoader，开始进行加载 整个加载过程是同步的，按 plugin > config > extend > agent.js > 其他文件顺序加载</li>\\n<li>agent.js 可自定义初始化，支持异步启动，如果定义了 beforeStart 会等待执行完成之后通知 Master 启动完成。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>Master 得到 Agent Worker 启动成功的消息，使用 cluster fork App Worker</strong></p>\\n<ul>\\n<li>App Worker 有多个进程，所以这几个进程是并行启动的，但执行逻辑是一致的</li>\\n<li>单个 App Worker 和 Agent 类似，通过 framework 找到框架目录，实例化该框架的 Application 类</li>\\n<li>Application 找到 AppWorkerLoader，开始进行加载，顺序也是类似的，会异步等待，完成后通知 Master 启动完成</li>\\n</ul>\\n</li>\\n<li><strong>Master 等待多个 App Worker 的成功消息后启动完成，能对外提供服务。</strong></li>\\n</ul>\\n<p>在Master的构造函数中，我们会发现，master在创建的时候会检测端口号并启动一个agent服务:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token function\\\">detectPort</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">(</span>err<span class=\\\"token punctuation\\\">,</span> port<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>err<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    err<span class=\\\"token punctuation\\\">.</span>name <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'ClusterPortConflictError'</span><span class=\\\"token punctuation\\\">;</span>\\n    err<span class=\\\"token punctuation\\\">.</span>message <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'[master] try get free port error, '</span> <span class=\\\"token operator\\\">+</span> err<span class=\\\"token punctuation\\\">.</span>message<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>logger<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">error</span><span class=\\\"token punctuation\\\">(</span>err<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    process<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">exit</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>options<span class=\\\"token punctuation\\\">.</span>clusterPort <span class=\\\"token operator\\\">=</span> port<span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">forkAgentWorker</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>这里的<code class=\\\"language-text\\\">detectPort</code>之前也没有很多的用到，简单的查看了一下官方的源代码，大致就是逐个端口去监听，检测到一个空闲的端口并返回，将这个端口号赋值在<code class=\\\"language-text\\\">options.clusterPort</code>上，我们可以在<code class=\\\"language-text\\\">Agent</code>中获取到这个参数:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token keyword\\\">const</span> args <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">[</span> <span class=\\\"token constant\\\">JSON</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">stringify</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>options<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">const</span> agentWorker <span class=\\\"token operator\\\">=</span> childprocess<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">fork</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getAgentWorkerFile</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span> args<span class=\\\"token punctuation\\\">,</span> opt<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>这里的<code class=\\\"language-text\\\">getAgentWorkerFile()</code>返回的就是<code class=\\\"language-text\\\">egg-cluster</code>中的<code class=\\\"language-text\\\">agent_worker.js</code>文件，所以在Master创建的时候，会fork一个agent_worker的子进程，传入的参数就是master的options，因此检测的<code class=\\\"language-text\\\">clusterPort</code>会被使用在<code class=\\\"language-text\\\">agent</code>中，虽然再官方的framework中并没有使用这个端口，如果使用自定义的agent的话，可以考虑使用一下。</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token comment\\\">// agent_worker.js</span>\\n<span class=\\\"token keyword\\\">const</span> Agent <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span>options<span class=\\\"token punctuation\\\">.</span>framework<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>Agent<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">debug</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'new Agent with options %j'</span><span class=\\\"token punctuation\\\">,</span> options<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">const</span> agent <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Agent</span><span class=\\\"token punctuation\\\">(</span>options<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nagent<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">ready</span><span class=\\\"token punctuation\\\">(</span>err <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>err<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token keyword\\\">return</span><span class=\\\"token punctuation\\\">;</span>\\n  agent<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">removeListener</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'error'</span><span class=\\\"token punctuation\\\">,</span> startErrorHandler<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  process<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">send</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">{</span> action<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'agent-start'</span><span class=\\\"token punctuation\\\">,</span> to<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'master'</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>在agent_worker中，直接创建了Agent的对象，这个Agent是从我们指定的Framework中获取的，在agent成功ready之后会向master发送一个<code class=\\\"language-text\\\">agent-start</code>的消息。</p>\\n<p>发送了这个消息之后，究竟会发生什么情况？上述的官方的描述中提到</p>\\n<blockquote>\\n<p>Master 得到 Agent Worker 启动成功的消息，使用 cluster fork App Worker</p>\\n</blockquote>\\n<p>那么，源码中的事实如何？我们可以搜索一下<code class=\\\"language-text\\\">agent-start</code>的关键词。</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">on</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'agent-start'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>onAgentStart<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">bind</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token comment\\\">// ......</span>\\n<span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">once</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'agent-start'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>forkAppWorkers<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">bind</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>前者大部分时间的情况下就是打印一下agent启动后的信息，后者顾明思议，启动了若干个workers。</p>\\n<p>查看了一下<code class=\\\"language-text\\\">forkAppWorkers</code>的源码，这可和<code class=\\\"language-text\\\">forkAgentWorker</code>这个做法不同，在<code class=\\\"language-text\\\">forkAgentWorker</code>中是使用<code class=\\\"language-text\\\">childprocess.fork</code>的方式来启动一个子进程的，而<code class=\\\"language-text\\\">forkAppWorkers</code>中用了很多的<code class=\\\"language-text\\\">cluster</code>库。Node官方是这么说明的：</p>\\n<blockquote>\\n<p>A single instance of Node.js runs in a single thread. To take advantage of multi-core systems, the user will sometimes want to launch a cluster of Node.js processes to handle the load.\\n每个node都是单进程运行的。为了充分利用多核系统，开发者期望组建一个node.js进程的集群来处理。</p>\\n</blockquote>\\n<p>在egg的文档中也举出了这么个例子:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token keyword\\\">const</span> cluster <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'cluster'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">const</span> http <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'http'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">const</span> numCPUs <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'os'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">cpus</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>length<span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>cluster<span class=\\\"token punctuation\\\">.</span>isMaster<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">let</span> i <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span> i <span class=\\\"token operator\\\">&lt;</span> numCPUs<span class=\\\"token punctuation\\\">;</span> i<span class=\\\"token operator\\\">++</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    cluster<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">fork</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  cluster<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">on</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'exit'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">function</span><span class=\\\"token punctuation\\\">(</span>worker<span class=\\\"token punctuation\\\">,</span> code<span class=\\\"token punctuation\\\">,</span> signal<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'worker '</span> <span class=\\\"token operator\\\">+</span> worker<span class=\\\"token punctuation\\\">.</span>process<span class=\\\"token punctuation\\\">.</span>pid <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">' died'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n  http<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">createServer</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span><span class=\\\"token punctuation\\\">(</span>req<span class=\\\"token punctuation\\\">,</span> res<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    res<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">writeHead</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">200</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    res<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">end</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"hello world\\\\n\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">listen</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">8000</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>这段代码fork了若干个进程，这些进程都会用于处理监听8000的端口号，在同一个端口号下作了负载，而使用<code class=\\\"language-text\\\">childProcess.fork</code>的话，监听相同端口号会失败，因此这就是cluster的用处。</p>\\n<p>在egg-cluster中并没有显示的调用<code class=\\\"language-text\\\">cluster.fork</code>，可以找到的是它调用了一个叫做<a href=\\\"https://github.com/node-modules/cfork\\\">cfork</a>的库。在刚开始看源码的时候就看了一下这个库，但没有太仔细的查看，大致知道这是个充分利用cpu来执行<code class=\\\"language-text\\\">cluster.fork</code>的工具，然后针对官方有关健壮性中提到的:</p>\\n<blockquote>\\n<ul>\\n<li>关闭异常 Worker 进程所有的 TCP Server（将已有的连接快速断开，且不再接收新的连接），断开和 Master 的 IPC 通道，不再接受新的用户请求。</li>\\n<li>Master 立刻 fork 一个新的 Worker 进程，保证在线的『工人』总数不变。</li>\\n<li>异常 Worker 等待一段时间，处理完已经接受的请求后退出。</li>\\n</ul>\\n</blockquote>\\n<p>我一直在寻找对应的代码，因为寻遍了egg-cluster和egg仓库，合理的处理cluster的exit的事件的只有这些代码:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\">cluster<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">on</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'exit'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token punctuation\\\">(</span>worker<span class=\\\"token punctuation\\\">,</span> code<span class=\\\"token punctuation\\\">,</span> signal<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>messenger<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">send</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">{</span>\\n    action<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'app-exit'</span><span class=\\\"token punctuation\\\">,</span>\\n    data<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span> workerPid<span class=\\\"token punctuation\\\">:</span> worker<span class=\\\"token punctuation\\\">.</span>process<span class=\\\"token punctuation\\\">.</span>pid<span class=\\\"token punctuation\\\">,</span> code<span class=\\\"token punctuation\\\">,</span> signal <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n    to<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'master'</span><span class=\\\"token punctuation\\\">,</span>\\n    <span class=\\\"token keyword\\\">from</span><span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'app'</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>而这个代码的消息最后会调用<code class=\\\"language-text\\\">onAppExit()</code>这个函数，而这个函数只是将worker冲workerManager中删除和清除一些监听，充其量就是一个clean的操作，并没有关于<strong>fork一个新的Worker进程</strong>的操作，这是我困惑不已，排除了很多可能后终于在cfork这个仓库中找到了相关的代码，原来之前漏看了很多代码，这个cfork本身就提供了所谓:</p>\\n<blockquote>\\n<p>Master 立刻 fork 一个新的 Worker 进程，保证在线的『工人』总数不变</p>\\n</blockquote>\\n<p>本文主要是从官方文档的功能为入口，从源码的角度来验证具体的实现，解析了egg启动后的agent和app的执行顺序，fork workers的实现和worker报错后的行为。还是有很多地方没讲清楚，需要读者自行阅读以下源码。</p>\",\"frontmatter\":{\"title\":\"egg的集群管理\",\"date\":\"25 December, 2018\",\"tag\":\"node,egg\"}}},\"pathContext\":{\"slug\":\"node-cluster-in-egg\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---posts-node-cluster-in-egg-20fc589c4c6c0d898f06.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<blockquote>\\n<p>在之前的文章<a href=\\\"/posts/pre-deep-into-egg-core\\\">深入egg-core前篇</a>中已经讲述了一个道理，node之所以没有成为一个比较流行的服务器语言，是因为node需要一个企业级的框架。而egg或许是一个不错的选择，针对egg-core的内部实现，将会在这篇文章中作出探索。</p>\\n</blockquote>\\n<p>初学node来编写server一般都是简单的启动一个挂起的的node进程:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token comment\\\">// server.js</span>\\n<span class=\\\"token keyword\\\">const</span> server <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'http'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">createServer</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span><span class=\\\"token punctuation\\\">(</span>req<span class=\\\"token punctuation\\\">,</span> res<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  res<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">write</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'ok'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  res<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">end</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nserver<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">listen</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">3000</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>启动这个server.js后，会启动一个挂起的node的进程，然后我们访问<a href=\\\"http://localhost:3000\\\">页面</a>的时候就会收到返回值了。</p>\\n<p>这是比较基本的启动一个node服务的方式，但是这种方式太基础，没有考虑到生产环境的需求。一个服务被部署到生产环境会衍生出一些额外的需求：</p>\\n<ul>\\n<li>\\n<p><strong>可扩展性</strong> 生产环境中，用户的访问量不是像我们启动一个服务器来测试这样小的规模，有的时候会有较大的并发量，我们通常会采用集群的方式来解决这个问题，即发布启动若干个服务，然后让请求负载到这些服务上，就可以将较大的访问量拆解到比较合适的访问量，所以服务的可扩展性是很重要的。node是单进程处理请求的，所以有的时候我们可能会让一个端口的监听事件发布到若干个node进程中，也会起到负载均衡的作用。</p>\\n</li>\\n<li>\\n<p><strong>健壮性</strong> 在egg的<a href=\\\"https://eggjs.org/zh-cn/core/cluster-and-ipc.html#%E8%BF%9B%E7%A8%8B%E5%AE%88%E6%8A%A4\\\">文档</a>中也是有提到的，node在遇到未捕获异常的时候会退出，如果没有一个兜底的处理的话，最后应用会挂掉，这在生产环境中是不可容忍的，针对这点Node提供了<code class=\\\"language-text\\\">process.on(&#39;uncaughtException&#39;, handler)</code>来处理这个异常。</p>\\n</li>\\n</ul>\\n<p>egg在这方面有相关的处理，这些处理大部分都被放在<a href=\\\"https://github.com/eggjs/egg-cluster\\\">egg-cluster</a>中，在官方文档中，有明确的图阐述了内部的egg-cluster的处理逻辑:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"text\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">                +--------+          +-------+\\n                | Master |&lt;--------&gt;| Agent |\\n                +--------+          +-------+\\n                ^   ^    ^\\n               /    |     \\\\\\n             /      |       \\\\\\n           /        |         \\\\\\n         v          v          v\\n+----------+   +----------+   +----------+\\n| Worker 1 |   | Worker 2 |   | Worker 3 |\\n+----------+   +----------+   +----------+</code></pre>\\n      </div>\\n<p>假如我们启动了一个生产环境的egg服务，我们通常会执行:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"bash\\\">\\n      <pre class=\\\"language-bash\\\"><code class=\\\"language-bash\\\">egg-scripts start --daemon --title<span class=\\\"token operator\\\">=</span>xxxxx</code></pre>\\n      </div>\\n<p>这里的egg-scripts的命令行工具，我们可以一窥</p>\\n<p>在其项目中的<code class=\\\"language-text\\\">start.js</code>的脚本中，组装了一些命令行参数，最后会执行<code class=\\\"language-text\\\">start-cluster</code>这个node脚本:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token keyword\\\">const</span> options <span class=\\\"token operator\\\">=</span> <span class=\\\"token constant\\\">JSON</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">parse</span><span class=\\\"token punctuation\\\">(</span>process<span class=\\\"token punctuation\\\">.</span>argv<span class=\\\"token punctuation\\\">[</span><span class=\\\"token number\\\">2</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span>options<span class=\\\"token punctuation\\\">.</span>framework<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">startCluster</span><span class=\\\"token punctuation\\\">(</span>options<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>这里的framework是什么，默认是egg提供的framework，你也可以像<a href=\\\"https://eggjs.org/zh-cn/advanced/framework.html\\\">文档</a>中说的一样，自己定义一个framework，在配置文件中指明使用自己的framework，在framework中，需要被导出一个<code class=\\\"language-text\\\">startCluster</code>的函数，这个函数就是这里被调用的函数。在官方默认的egg的framework中，只是直接引用了<code class=\\\"language-text\\\">egg-cluster</code>的输出:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\">exports<span class=\\\"token punctuation\\\">.</span>startCluster <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'egg-cluster'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>startCluster<span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>关注一下<code class=\\\"language-text\\\">egg-cluster</code>中的实现，可以发现，startCluster的第一步，就是创建一个Master:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\">exports<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function-variable function\\\">startCluster</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span><span class=\\\"token punctuation\\\">(</span>options<span class=\\\"token punctuation\\\">,</span> callback<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Master</span><span class=\\\"token punctuation\\\">(</span>options<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">ready</span><span class=\\\"token punctuation\\\">(</span>callback<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>在官方文档中有这样的描述:</p>\\n<ul>\\n<li><strong>startCluster 启动传入 baseDir 和 framework，Master 进程启动</strong></li>\\n<li>\\n<p><strong>Master 先 fork Agent Worker</strong></p>\\n<ul>\\n<li>根据 framework 找到框架目录，实例化该框架的 Agent 类</li>\\n<li>Agent 找到定义的 AgentWorkerLoader，开始进行加载</li>\\n<li>AgentWorkerLoader，开始进行加载 整个加载过程是同步的，按 plugin > config > extend > agent.js > 其他文件顺序加载</li>\\n<li>agent.js 可自定义初始化，支持异步启动，如果定义了 beforeStart 会等待执行完成之后通知 Master 启动完成。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>Master 得到 Agent Worker 启动成功的消息，使用 cluster fork App Worker</strong></p>\\n<ul>\\n<li>App Worker 有多个进程，所以这几个进程是并行启动的，但执行逻辑是一致的</li>\\n<li>单个 App Worker 和 Agent 类似，通过 framework 找到框架目录，实例化该框架的 Application 类</li>\\n<li>Application 找到 AppWorkerLoader，开始进行加载，顺序也是类似的，会异步等待，完成后通知 Master 启动完成</li>\\n</ul>\\n</li>\\n<li><strong>Master 等待多个 App Worker 的成功消息后启动完成，能对外提供服务。</strong></li>\\n</ul>\\n<p>在Master的构造函数中，我们会发现，master在创建的时候会检测端口号并启动一个agent服务:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token function\\\">detectPort</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">(</span>err<span class=\\\"token punctuation\\\">,</span> port<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>err<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    err<span class=\\\"token punctuation\\\">.</span>name <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'ClusterPortConflictError'</span><span class=\\\"token punctuation\\\">;</span>\\n    err<span class=\\\"token punctuation\\\">.</span>message <span class=\\\"token operator\\\">=</span> <span class=\\\"token string\\\">'[master] try get free port error, '</span> <span class=\\\"token operator\\\">+</span> err<span class=\\\"token punctuation\\\">.</span>message<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>logger<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">error</span><span class=\\\"token punctuation\\\">(</span>err<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    process<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">exit</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>options<span class=\\\"token punctuation\\\">.</span>clusterPort <span class=\\\"token operator\\\">=</span> port<span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">forkAgentWorker</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>这里的<code class=\\\"language-text\\\">detectPort</code>之前也没有很多的用到，简单的查看了一下官方的源代码，大致就是逐个端口去监听，检测到一个空闲的端口并返回，将这个端口号赋值在<code class=\\\"language-text\\\">options.clusterPort</code>上，我们可以在<code class=\\\"language-text\\\">Agent</code>中获取到这个参数:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token keyword\\\">const</span> args <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">[</span> <span class=\\\"token constant\\\">JSON</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">stringify</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>options<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">const</span> agentWorker <span class=\\\"token operator\\\">=</span> childprocess<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">fork</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getAgentWorkerFile</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span> args<span class=\\\"token punctuation\\\">,</span> opt<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>这里的<code class=\\\"language-text\\\">getAgentWorkerFile()</code>返回的就是<code class=\\\"language-text\\\">egg-cluster</code>中的<code class=\\\"language-text\\\">agent_worker.js</code>文件，所以在Master创建的时候，会fork一个agent_worker的子进程，传入的参数就是master的options，因此检测的<code class=\\\"language-text\\\">clusterPort</code>会被使用在<code class=\\\"language-text\\\">agent</code>中，虽然再官方的framework中并没有使用这个端口，如果使用自定义的agent的话，可以考虑使用一下。</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token comment\\\">// agent_worker.js</span>\\n<span class=\\\"token keyword\\\">const</span> Agent <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span>options<span class=\\\"token punctuation\\\">.</span>framework<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>Agent<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token function\\\">debug</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'new Agent with options %j'</span><span class=\\\"token punctuation\\\">,</span> options<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">const</span> agent <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Agent</span><span class=\\\"token punctuation\\\">(</span>options<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nagent<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">ready</span><span class=\\\"token punctuation\\\">(</span>err <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>err<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token keyword\\\">return</span><span class=\\\"token punctuation\\\">;</span>\\n  agent<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">removeListener</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'error'</span><span class=\\\"token punctuation\\\">,</span> startErrorHandler<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  process<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">send</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">{</span> action<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'agent-start'</span><span class=\\\"token punctuation\\\">,</span> to<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'master'</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>在agent_worker中，直接创建了Agent的对象，这个Agent是从我们指定的Framework中获取的，在agent成功ready之后会向master发送一个<code class=\\\"language-text\\\">agent-start</code>的消息。</p>\\n<p>发送了这个消息之后，究竟会发生什么情况？上述的官方的描述中提到</p>\\n<blockquote>\\n<p>Master 得到 Agent Worker 启动成功的消息，使用 cluster fork App Worker</p>\\n</blockquote>\\n<p>那么，源码中的事实如何？我们可以搜索一下<code class=\\\"language-text\\\">agent-start</code>的关键词。</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">on</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'agent-start'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>onAgentStart<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">bind</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token comment\\\">// ......</span>\\n<span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">once</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'agent-start'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>forkAppWorkers<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">bind</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>前者大部分时间的情况下就是打印一下agent启动后的信息，后者顾明思议，启动了若干个workers。</p>\\n<p>查看了一下<code class=\\\"language-text\\\">forkAppWorkers</code>的源码，这可和<code class=\\\"language-text\\\">forkAgentWorker</code>这个做法不同，在<code class=\\\"language-text\\\">forkAgentWorker</code>中是使用<code class=\\\"language-text\\\">childprocess.fork</code>的方式来启动一个子进程的，而<code class=\\\"language-text\\\">forkAppWorkers</code>中用了很多的<code class=\\\"language-text\\\">cluster</code>库。Node官方是这么说明的：</p>\\n<blockquote>\\n<p>A single instance of Node.js runs in a single thread. To take advantage of multi-core systems, the user will sometimes want to launch a cluster of Node.js processes to handle the load.\\n每个node都是单进程运行的。为了充分利用多核系统，开发者期望组建一个node.js进程的集群来处理。</p>\\n</blockquote>\\n<p>在egg的文档中也举出了这么个例子:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token keyword\\\">const</span> cluster <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'cluster'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">const</span> http <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'http'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">const</span> numCPUs <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'os'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">cpus</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span>length<span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>cluster<span class=\\\"token punctuation\\\">.</span>isMaster<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">let</span> i <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span> i <span class=\\\"token operator\\\">&lt;</span> numCPUs<span class=\\\"token punctuation\\\">;</span> i<span class=\\\"token operator\\\">++</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    cluster<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">fork</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  cluster<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">on</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'exit'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">function</span><span class=\\\"token punctuation\\\">(</span>worker<span class=\\\"token punctuation\\\">,</span> code<span class=\\\"token punctuation\\\">,</span> signal<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'worker '</span> <span class=\\\"token operator\\\">+</span> worker<span class=\\\"token punctuation\\\">.</span>process<span class=\\\"token punctuation\\\">.</span>pid <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">' died'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n  http<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">createServer</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span><span class=\\\"token punctuation\\\">(</span>req<span class=\\\"token punctuation\\\">,</span> res<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    res<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">writeHead</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">200</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    res<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">end</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"hello world\\\\n\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">listen</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">8000</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>这段代码fork了若干个进程，这些进程都会用于处理监听8000的端口号，在同一个端口号下作了负载，而使用<code class=\\\"language-text\\\">childProcess.fork</code>的话，监听相同端口号会失败，因此这就是cluster的用处。</p>\\n<p>在egg-cluster中并没有显示的调用<code class=\\\"language-text\\\">cluster.fork</code>，可以找到的是它调用了一个叫做<a href=\\\"https://github.com/node-modules/cfork\\\">cfork</a>的库。在刚开始看源码的时候就看了一下这个库，但没有太仔细的查看，大致知道这是个充分利用cpu来执行<code class=\\\"language-text\\\">cluster.fork</code>的工具，然后针对官方有关健壮性中提到的:</p>\\n<blockquote>\\n<ul>\\n<li>关闭异常 Worker 进程所有的 TCP Server（将已有的连接快速断开，且不再接收新的连接），断开和 Master 的 IPC 通道，不再接受新的用户请求。</li>\\n<li>Master 立刻 fork 一个新的 Worker 进程，保证在线的『工人』总数不变。</li>\\n<li>异常 Worker 等待一段时间，处理完已经接受的请求后退出。</li>\\n</ul>\\n</blockquote>\\n<p>我一直在寻找对应的代码，因为寻遍了egg-cluster和egg仓库，合理的处理cluster的exit的事件的只有这些代码:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"javascript\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\">cluster<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">on</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'exit'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token punctuation\\\">(</span>worker<span class=\\\"token punctuation\\\">,</span> code<span class=\\\"token punctuation\\\">,</span> signal<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=></span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>messenger<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">send</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">{</span>\\n    action<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'app-exit'</span><span class=\\\"token punctuation\\\">,</span>\\n    data<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token punctuation\\\">{</span> workerPid<span class=\\\"token punctuation\\\">:</span> worker<span class=\\\"token punctuation\\\">.</span>process<span class=\\\"token punctuation\\\">.</span>pid<span class=\\\"token punctuation\\\">,</span> code<span class=\\\"token punctuation\\\">,</span> signal <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">,</span>\\n    to<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'master'</span><span class=\\\"token punctuation\\\">,</span>\\n    <span class=\\\"token keyword\\\">from</span><span class=\\\"token punctuation\\\">:</span> <span class=\\\"token string\\\">'app'</span><span class=\\\"token punctuation\\\">,</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>而这个代码的消息最后会调用<code class=\\\"language-text\\\">onAppExit()</code>这个函数，而这个函数只是将worker冲workerManager中删除和清除一些监听，充其量就是一个clean的操作，并没有关于<strong>fork一个新的Worker进程</strong>的操作，这是我困惑不已，排除了很多可能后终于在cfork这个仓库中找到了相关的代码，原来之前漏看了很多代码，这个cfork本身就提供了所谓:</p>\\n<blockquote>\\n<p>Master 立刻 fork 一个新的 Worker 进程，保证在线的『工人』总数不变</p>\\n</blockquote>\\n<p>本文主要是从官方文档的功能为入口，从源码的角度来验证具体的实现，解析了egg启动后的agent和app的执行顺序，fork workers的实现和worker报错后的行为。还是有很多地方没讲清楚，需要读者自行阅读以下源码。</p>\",\"frontmatter\":{\"title\":\"egg的集群管理\",\"date\":\"25 December, 2018\",\"tag\":\"node,egg\"}}},\"pathContext\":{\"slug\":\"node-cluster-in-egg\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/posts-node-cluster-in-egg.json\n// module id = 384\n// module chunks = 236081119161127"],"sourceRoot":""}