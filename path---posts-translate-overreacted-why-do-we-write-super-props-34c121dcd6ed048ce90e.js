webpackJsonp([60536836248096],{401:function(s,n){s.exports={data:{markdownRemark:{html:'<blockquote>\n<p>本文出自<a href="https://overreacted.io/">overreacted</a>，这是<a href="https://mobile.twitter.com/dan_abramov">Dan Abramov</a>写的博客，我觉得对很有用所以特意做了这个翻译<a href="/posts/overreacted">系列</a>，原文链接请查看<a href="https://overreacted.io/why-do-we-write-super-props/">这里</a></p>\n</blockquote>\n<p>听说最近好像<a href="https://reactjs.org/docs/hooks-intro.html">Hooks</a>是一个热议的话题。可笑的是我的第一篇博客和这个相去甚远，我希望能够描述好组件class的内部巧妙的实现。不知道大家对这点是否有兴趣。</p>\n<p><strong>这些内部巧妙的实现可能对在生产环境中使用React并<em>没有</em>特别大的益处，但是针对那些渴望知道React的内部的人来说会觉得非常有趣。</strong></p>\n<p>那么第一个例子来了</p>\n<hr>\n<p>我这辈子写过无数个<code class="language-text">super(props)</code>，比如：</p>\n<div class="gatsby-highlight" data-language="js">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Checkbox</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> isOn<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>当然，<a href="https://github.com/tc39/proposal-class-fields">类属性提案</a>让我们可以跳过这种写法</p>\n<div class="gatsby-highlight" data-language="js">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Checkbox</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  state <span class="token operator">=</span> <span class="token punctuation">{</span> isOn<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>为了使用纯类定义，有一个<a href="https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#es7-property-initializers">语法</a>早在2015年React 0.13的时候就已经有计划了。定义<code class="language-text">constructor</code>并调用<code class="language-text">super(props)</code>只是在类属性提案提供一个人性化的选择之前作为一个临时的选择</p>\n<p>所以，让我们回到这个例子的ES2015版本的写法:</p>\n<div class="gatsby-highlight" data-language="js">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Checkbox</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n<span class="gatsby-highlight-code-line">    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> isOn<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p><strong>为什么我们需要调用<code class="language-text">super</code>? 我们可以<em>不</em>调用它么？如果我们调用它，如果我们不传<code class="language-text">props</code>这个参数会发生什么？还可以传其他什么更多的参数么？</strong> 让我们来了解一下</p>\n<hr>\n<p>在Javascipt中, <code class="language-text">super</code>引用了父类的构造函数。(在我们的例子中，这指向了<code class="language-text">React.Component</code>的实现)</p>\n<p>更加重要的是，你在构造函数中不能再调用父类的构造函数<em>之前</em>使用<code class="language-text">this</code>。Javascript不会让你像这么做：</p>\n<div class="gatsby-highlight" data-language="js">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Checkbox</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 🔴 还不能使用`this`</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// ✅ 嘿，现在可以了</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> isOn<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>针对为什么JavaScript必须让你在使用<code class="language-text">this</code>之前调用父类的构造函数的原因，这里有个关于类继承的例子:</p>\n<div class="gatsby-highlight" data-language="js">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">PolitePerson</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">greetColleagues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 🔴 这是不被允许的，详细请看下面</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">greetColleagues</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">\'Good morning folks!\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>在<code class="language-text">super</code>之前使用<code class="language-text">this</code><em>假如是</em>允许的. 一个月之后，我们可能修改<code class="language-text">greetColleagues</code>的实现，并在弹出一个消息的时候使用了name的属性:</p>\n<div class="gatsby-highlight" data-language="js">\n      <pre class="language-js"><code class="language-js">  <span class="token function">greetColleagues</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">\'Good morning folks!\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">\'My name is \'</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">\', nice to meet you!\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span></code></pre>\n      </div>\n<p>但是我们忘记了<code class="language-text">this.greetColleagues()</code>在调用父类的构造函数之前被调用了，我们会以为<code class="language-text">this.name</code>已经被初始化了。但是<code class="language-text">this.name</code>并没有被定义，如你所见，这样的代码任然非常难理解。</p>\n<p>为了避免这样的问题，<strong>JavaScript必须让你在使用<code class="language-text">this</code>之前调用父类的构造函数，你<em>必须</em>先调用父类的构造函数</strong>。让父类做它自己的事情！但是这个定义类的限制也同样作用于React的组件定义:</p>\n<div class="gatsby-highlight" data-language="js">\n      <pre class="language-js"><code class="language-js">  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// ✅ 好啦！现在能够使用`this`了</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> isOn<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span></code></pre>\n      </div>\n<p>这让我们产生了另一个问题：为什么需要传<code class="language-text">props</code></p>\n<hr>\n<p>你可能会觉得将props传递到父类的构造函数中，这样父类<code class="language-text">React.Component</code>的构造函数就能够初始化<code class="language-text">this.props</code></p>\n<div class="gatsby-highlight" data-language="js">\n      <pre class="language-js"><code class="language-js"><span class="token comment">// React内部</span>\n<span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>props <span class="token operator">=</span> props<span class="token punctuation">;</span>\n    <span class="token comment">// ...</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>其实这里真相已经不远了 - <a href="https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22">React真正做的事情</a>其实是这样的</p>\n<p>接下来有个令人不解的问题就是，即使你在调用父类的构造函数的时候没有传递<code class="language-text">props</code>参数，你也依然可以在<code class="language-text">render</code>或者其他的成员函数中访问<code class="language-text">this.props</code>(如果你不相信我，可以自己尝试一下)</p>\n<p><em>上述</em>的现象是如何产生的？显而易见,这个现象证明了<strong>React还会在调用<em>你的</em>构造函数之后，为生成的实例的<code class="language-text">props</code>赋值</strong></p>\n<div class="gatsby-highlight" data-language="js">\n      <pre class="language-js"><code class="language-js">  <span class="token comment">// React内部</span>\n  <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">YourComponent</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  instance<span class="token punctuation">.</span>props <span class="token operator">=</span> props<span class="token punctuation">;</span></code></pre>\n      </div>\n<p>所以即使你忘记掉在调用<code class="language-text">super()</code>的时候传入<code class="language-text">props</code>，React依然会在构造函数结束之后将<code class="language-text">props</code>赋值，这就是产生这个现象的原因</p>\n<p>当React要添加对class的支持的时候，这不只是代表着React单纯的只是支持ES6 class，React的目标是尽可能的支持最宽泛的class的概念。当时还<a href="https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#other-languages">不能够确定</a>ClojureScript, CoffeeScript, ES6, Fable, Scala.js, TypeScript或者其他语言那种相对来说用于定义组件会比较好。所以React特意对是否必须调用<code class="language-text">super()</code>不敢妄自约束 - 即使是ES6的类。</p>\n<p>那么难道这就意味着你能够使用<code class="language-text">super()</code>而不去调用<code class="language-text">super(props)</code>？</p>\n<p><strong>可能还是不可以这么做，因为这还存在一些问题</strong> 当然，React会在调用构造函数之后为<code class="language-text">this.props</code>赋值。但是在调用了<code class="language-text">super</code>和构造函数结束之间<code class="language-text">this.props</code>还是<code class="language-text">undefuned</code>:</p>\n<div class="gatsby-highlight" data-language="js">\n      <pre class="language-js"><code class="language-js"><span class="token comment">// Inside React</span>\n<span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>props <span class="token operator">=</span> props<span class="token punctuation">;</span>\n    <span class="token comment">// ...</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 你的代码</span>\n<span class="token keyword">class</span> <span class="token class-name">Button</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 😬 我们忘记了将props传入</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// ✅ {}</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 😬 undefined </span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>你也可以做更多的尝试，比如在一些函数中调用<code class="language-text">this.props</code>，然后在<em>构造函数中</em>调用这些函数，看看结果如何。<strong>这也是为什么我推荐你最好能够总是将props传到父类的构造函数中，即使这并不是严格上必须的</strong></p>\n<div class="gatsby-highlight" data-language="js">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Button</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ 我们传入了props</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// ✅ {}</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ✅ {}</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>这确保了<code class="language-text">this.props</code>在构造函数结束之前就被初始化</p>\n<hr>\n<p>这里还有一点，很长的一段时间里，React的使用者都非常的好奇。</p>\n<p>你可能注意到，当你在class中使用 context api(无论是老的<code class="language-text">contextTypes</code>或者现在的React16.6的<code class="language-text">contextType</code>API)，<code class="language-text">context</code>会作为第二个参数传递到构造函数中。</p>\n<p>但是我们会像<code class="language-text">super(props, context)</code>这么写么？我们可以这么做，但是context会用的比较低频，相同的context的问题并不会像props这么多。</p>\n<p><strong>通过类属性提案，这些问题大多数都能够解决</strong>即使没有明确构造函数的定义，所有的参数都能够自动的传入父类，这让我们可以通过类似于<code class="language-text">state = {}</code>的表达式来赋值<code class="language-text">this.props</code>或者<code class="language-text">this.contxt</code></p>\n<p>通过 Hooks，我们甚至可以不使用<code class="language-text">super</code>或者<code class="language-text">this</code>。但这是下次的话题了</p>',frontmatter:{title:"翻译：为什么我们需要些super(props)",date:"30 November, 2018",tag:"translate,overreacted"}}},pathContext:{slug:"translate-overreacted-why-do-we-write-super-props"}}}});
//# sourceMappingURL=path---posts-translate-overreacted-why-do-we-write-super-props-34c121dcd6ed048ce90e.js.map